// Prisma Schema for Roatan Poker League
// Documentation: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// USER & AUTHENTICATION
// ============================================

enum UserRole {
  ADMIN
  VENUE_MANAGER
  TOURNAMENT_DIRECTOR
  PLAYER
}

enum AuthProvider {
  EMAIL
  GOOGLE
  LIGHTNING
}

model User {
  id            String       @id @default(cuid())
  email         String?      @unique
  password      String?      // Null for OAuth/Lightning users
  name          String
  nameSetAt     DateTime?    // When name was set (null = can still change, set = locked)
  role          UserRole     @default(PLAYER)
  avatar        String?
  isActive      Boolean      @default(true)
  emailVerified Boolean      @default(false)
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
  lastLoginAt   DateTime?    // Track last login for sorting
  
  // Multi-auth support
  authProvider    AuthProvider @default(EMAIL)
  googleId        String?      @unique
  lightningPubkey String?      @unique
  
  // Lightning balance (sats owed to user)
  lightningBalanceSats Int      @default(0)
  
  // Guest flag (for walk-in players added by TD)
  isGuest       Boolean      @default(false)
  
  // Claim token (for guest account claiming via link)
  claimToken       String?   @unique
  claimTokenExpiry DateTime?
  
  // Admin-only notes (hidden from user)
  adminNotes    String?

  // Telegram notification preferences (admin only)
  // { newUser: true, withdrawal: true, venueApplication: true }
  notificationPrefs Json?

  // Relations
  profile           Profile?
  managedVenues     Venue[]          @relation("VenueManager")
  directedEvents    Event[]          @relation("EventDirector")
  eventSignups      EventSignup[]
  results           Result[]
  standings         Standing[]
  earnedAchievements UserAchievement[]
  comments          Comment[]
  withdrawals       Withdrawal[]
  pointsHistory     PointsHistory[]
  venueApplicationsSubmitted VenueApplication[] @relation("VenueApplicationSubmitter")
  venueApplicationsReviewed  VenueApplication[] @relation("VenueApplicationReviewer")
  lastLongerEntries          LastLongerEntry[]
  lastLongerWins             Event[]            @relation("LastLongerWinner")
  puzzleAttempts             PuzzleAttempt[]

  @@map("users")
}

model Profile {
  id              String   @id @default(cuid())
  userId          String   @unique
  bio             String?
  profileImage    String?  // Base64 encoded profile photo
  phone           String?
  telegramUsername String? // Telegram @handle (without @)
  telegramVerified Boolean @default(false) // True once a test DM was successfully delivered
  socialLinks     Json?    // { facebook, twitter, instagram }
  
  // Stats (denormalized for quick access)
  totalEvents     Int @default(0)
  totalWins       Int @default(0)
  totalPoints     Int @default(0)
  bestFinish      Int?
  averageFinish   Float?
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("profiles")
}

// ============================================
// VENUES
// ============================================

model Venue {
  id          String   @id @default(cuid())
  name        String
  address     String
  description String?
  imageUrl    String?
  phone       String?
  email       String?
  isActive    Boolean  @default(true)
  managerId   String?
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  manager            User?               @relation("VenueManager", fields: [managerId], references: [id])
  events             Event[]
  venueApplications  VenueApplication[]

  @@map("venues")
}

// ============================================
// SEASONS
// ============================================

model Season {
  id          String   @id @default(cuid())
  name        String   // e.g., "Spring 2024"
  startDate   DateTime
  endDate     DateTime
  isActive    Boolean  @default(false)
  
  // Points configuration (JSON for flexibility)
  pointsStructure Json // { "1": 100, "2": 75, "3": 60, ... "knockout": 2 }
  
  // Playoff configuration
  playoffQualifyCount Int @default(10) // Top N players qualify
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  events        Event[]
  standings     Standing[]
  pointsHistory PointsHistory[]

  @@map("seasons")
}

// ============================================
// EVENTS
// ============================================

enum EventStatus {
  SCHEDULED
  REGISTRATION_OPEN
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

model Event {
  id                    String      @id @default(cuid())
  name                  String      // e.g., "Tuesday Night Poker @ Blue Marlin"
  description           String?
  imageUrl              String?     // Base64 encoded image or URL
  dateTime              DateTime
  registrationOpenDays  Int         @default(10)  // Days before event when registration opens
  registrationCloseMinutes Int      @default(30)  // Minutes before event when registration closes (0 = never closes)
  maxPlayers            Int         @default(20)
  buyIn                 Float?      // Optional buy-in amount
  totalEntrants         Int?        // Manual override for total player count (for points calc)
  status                EventStatus @default(SCHEDULED)
  
  // Last Longer Pool
  lastLongerEnabled    Boolean  @default(false)
  lastLongerSeedSats   Int      @default(10000)
  lastLongerEntrySats  Int      @default(25000)
  lastLongerWinnerId   String?

  venueId     String
  seasonId    String
  directorId  String?
  
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  // Relations
  venue              Venue              @relation(fields: [venueId], references: [id])
  season             Season             @relation(fields: [seasonId], references: [id])
  director           User?              @relation("EventDirector", fields: [directorId], references: [id])
  lastLongerWinner   User?              @relation("LastLongerWinner", fields: [lastLongerWinnerId], references: [id])
  signups            EventSignup[]
  results            Result[]
  comments           Comment[]
  lastLongerEntries  LastLongerEntry[]

  @@map("events")
}

// ============================================
// EVENT SIGNUPS
// ============================================

enum SignupStatus {
  REGISTERED
  CONFIRMED
  CHECKED_IN
  CANCELLED
  NO_SHOW
  WAITLISTED
}

model EventSignup {
  id           String       @id @default(cuid())
  eventId      String
  userId       String
  status       SignupStatus @default(REGISTERED)
  registeredAt DateTime     @default(now())
  checkedInAt  DateTime?
  
  // Relations
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([eventId, userId])
  @@map("event_signups")
}

// ============================================
// RESULTS
// ============================================

model Result {
  id           String   @id @default(cuid())
  eventId      String
  userId       String
  position     Int      // Finishing position (1st, 2nd, etc.)
  knockouts    Int      @default(0)
  pointsEarned Int
  
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([eventId, userId])
  @@map("results")
}

// ============================================
// STANDINGS (Denormalized for performance)
// ============================================

model Standing {
  id           String   @id @default(cuid())
  seasonId     String
  userId       String
  totalPoints  Int      @default(0)
  eventsPlayed Int      @default(0)
  wins         Int      @default(0)
  topThrees    Int      @default(0)
  knockouts    Int      @default(0)
  rank         Int?
  
  updatedAt    DateTime @updatedAt

  // Relations
  season Season @relation(fields: [seasonId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([seasonId, userId])
  @@map("standings")
}

// ============================================
// ACHIEVEMENTS / BADGES
// ============================================

model Achievement {
  id          String   @id @default(cuid())
  name        String   @unique
  description String
  icon        String   // Emoji or icon name
  criteria    Json     // { type: "wins", count: 5 } or { type: "streak", count: 3 }
  points      Int      @default(0) // Bonus points for earning
  
  createdAt   DateTime @default(now())

  // Relations
  earnedBy UserAchievement[]

  @@map("achievements")
}

model UserAchievement {
  id            String   @id @default(cuid())
  userId        String
  achievementId String
  earnedAt      DateTime @default(now())

  // Relations
  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  achievement Achievement @relation(fields: [achievementId], references: [id], onDelete: Cascade)

  @@unique([userId, achievementId])
  @@map("user_achievements")
}

// ============================================
// LIGHTNING AUTH CHALLENGES
// ============================================

model LightningChallenge {
  id        String   @id @default(cuid())
  k1        String   @unique  // Random challenge
  used      Boolean  @default(false)
  userId    String?  // Set after successful auth
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@map("lightning_challenges")
}

// ============================================
// COMMENTS
// ============================================

model Comment {
  id        String   @id @default(cuid())
  content   String
  userId    String
  eventId   String
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@map("comments")
}

// ============================================
// DELETED USERS (Archive/Backup)
// ============================================

model DeletedUser {
  id            String   @id @default(cuid())
  originalId    String   // Original user ID before deletion
  userData      Json     // Full snapshot of user data at time of deletion
  deletedBy     String   // Admin who deleted the account
  reason        String?  // Optional reason for deletion
  deletedAt     DateTime @default(now())

  @@map("deleted_users")
}

// ============================================
// LIGHTNING WITHDRAWALS
// ============================================

enum WithdrawalStatus {
  PENDING    // Created, waiting for user to claim
  CLAIMED    // User submitted invoice, payment in progress
  PAID       // Successfully paid
  EXPIRED    // Timed out
  FAILED     // Payment failed
}

model Withdrawal {
  id          String           @id @default(cuid())
  k1          String           @unique  // LNURL secret identifier
  userId      String                    // Who this withdrawal is for
  amountSats  Int                       // Amount in satoshis
  description String?                   // e.g., "1st Place - Tuesday Poker"
  status      WithdrawalStatus @default(PENDING)
  invoice     String?                   // BOLT11 invoice when claimed
  paymentHash String?                   // Payment hash after successful payment
  paidAt      DateTime?
  expiresAt   DateTime
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("withdrawals")
}

// ============================================
// FAQ
// ============================================

model Faq {
  id        String   @id @default(cuid())
  question  String
  answer    String
  sortOrder Int      @default(0)
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("faqs")
}

// ============================================
// VENUE APPLICATIONS
// ============================================

enum VenueApplicationStatus {
  PENDING
  APPROVED
  REJECTED
}

model VenueApplication {
  id              String                 @id @default(cuid())
  name            String                 // Proposed venue name
  address         String
  description     String?
  imageUrl        String?
  phone           String?
  email           String?
  contactName     String                 // Applicant contact name
  contactEmail    String?                // Applicant contact email
  contactPhone    String?                // Applicant contact phone
  status          VenueApplicationStatus @default(PENDING)
  submittedById   String                 // User who submitted
  reviewedById    String?                // Admin who reviewed
  reviewedAt      DateTime?
  rejectionReason String?
  venueId         String?                // Created venue ID (set on approval)
  createdAt       DateTime               @default(now())
  updatedAt       DateTime               @updatedAt

  // Relations
  submittedBy User  @relation("VenueApplicationSubmitter", fields: [submittedById], references: [id], onDelete: Cascade)
  reviewedBy  User? @relation("VenueApplicationReviewer", fields: [reviewedById], references: [id])
  venue       Venue? @relation(fields: [venueId], references: [id])

  @@map("venue_applications")
}

// ============================================
// LAST LONGER POOL ENTRIES
// ============================================

model LastLongerEntry {
  id          String    @id @default(cuid())
  eventId     String
  userId      String
  amountSats  Int
  paymentHash String?   // Lightning invoice payment hash
  paidAt      DateTime?
  createdAt   DateTime  @default(now())

  // Relations
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([eventId, userId])
  @@map("last_longer_entries")
}

// ============================================
// POINTS HISTORY (Audit trail for all point changes)
// ============================================

model PointsHistory {
  id          String   @id @default(cuid())
  userId      String
  seasonId    String
  points      Int      // Can be positive or negative
  reason      String   // Required: "Manual by Jason", "2nd place on Friday #2", "Adding Lightning", etc.
  createdAt   DateTime @default(now())
  createdById String?  // Admin userId who made the change (null for system-generated)

  // Relations
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  season Season @relation(fields: [seasonId], references: [id], onDelete: Cascade)

  @@map("points_history")
}

// ============================================
// DAILY PUZZLES (Sats Faucet)
// ============================================

model DailyPuzzle {
  id           String    @id @default(cuid())
  sortOrder    Int       @default(0) // Queue position for unused puzzles
  usedAt       DateTime? @db.Date    // Date the puzzle was shown (null = unused/queued)
  scenario     String    // Context/flavor text shown above the question
  question     String    // The actual question
  options      Json      // Array of 5 answer strings
  correctIndex Int       // Index (0-4) of the correct answer
  explanation  String    // Shown after answering
  rewardSats   Int       @default(500)
  imageUrl     String?   // Optional image for the puzzle
  isActive     Boolean   @default(true)
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  // Relations
  attempts PuzzleAttempt[]

  @@map("daily_puzzles")
}

model PuzzleAttempt {
  id                 String   @id @default(cuid())
  puzzleId           String
  userId             String
  selectedIndex      Int      // Which option they chose
  isCorrect          Boolean
  satsAwarded        Int      @default(0)
  satsPending        Boolean  @default(false) // True if sats earned but not yet credited (user hasn't attended an event)
  isYesterdayAttempt Boolean  @default(false) // True if this was a catch-up attempt
  createdAt          DateTime @default(now())

  // Relations
  puzzle DailyPuzzle @relation(fields: [puzzleId], references: [id], onDelete: Cascade)
  user   User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([puzzleId, userId])
  @@map("puzzle_attempts")
}
